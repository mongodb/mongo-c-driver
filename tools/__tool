#!/usr/bin/env sh

# shellcheck disable=SC3043

set -eu

__init() {
    __alias __alias        __tool __alias
    __alias __bool         __tool __bool
    __alias __boolstr      __tool __boolstr
    __alias __can_install  __tool __can_install
    __alias __do           __tool __do
    __alias __fail         __tool __fail
    __alias __have_command __tool __have_command
    __alias __install      __tool __install
    __alias __purpose      __tool __purpose
    __alias __silently     __tool __silently
    __alias __str          __tool __str
}

# Usage: __readvar <dest> <varname>
# Read the value of the variable named by <varname> into a variable <dest>
__readvar() {
    local __readvar_tmp
    eval "__readvar_tmp=\$(printf %s. \"\${$2}\"); $1=\${__readvar_tmp%.}"
}

__fail() {
    # shellcheck disable=SC2059
    printf "$@"
    return 1
}

# $ __strsub_inplace <varname> <needle> <repl>
# Replace each occurrence of <needle> with <repl> within the string variable <varname>
__strsub_inplace() {
    test $# -eq 3 || __fail "__strsub_inplace expects three arguments (Got %s)" $# || return
    local __strsub_varname="$1" __strsub_needle="$2" __strsub_repl="$3"
    # Read the value of <varname> into __strsub_remaining
    __readvar __strsub_remaining "$__strsub_varname"
    # Accumulate into __strsub_acc
    local __strsub_head __strsub_acc=''
    while true; do
        # Grab all content until the next needle:
        __strsub_head=${__strsub_remaining%%"$__strsub_needle"*}
        if test "$__strsub_head" = "$__strsub_remaining"; then
            # Nothing match the needle, so we are done
            __strsub_acc="$__strsub_acc$__strsub_remaining"
            break
        fi
        # Everything after the needle:
        __strsub_remaining=${__strsub_remaining#*"$__strsub_needle"}
        # Accumulate the result:
        __strsub_acc="$__strsub_acc$__strsub_head$__strsub_repl"
    done
    # Read the accumulated string back into the output variable:
    __readvar "$__strsub_varname" __strsub_acc
}

_ESCAPES="$(printf '[][ \t\n\r\a*?!\\\$;()\\{\\}'"'"']')"
__quote() {
    local __quote_input="$1"
    # shellcheck disable=SC2295
    local __quote_tmp="${__quote_input#*$_ESCAPES}" || return
    if test "$__quote_input" = ""; then
        # Empty string: Just emit empty quotes
        printf '""'
        return
    elif test "$__quote_tmp" = "$__quote_input"; then
        # No special chars, so don't quote it:
        printf %s "$__quote_input"
        return
    else
        # Special chars. Escape any inner quotes, then wrap in quotes
        __strsub_inplace __quote_input "'" "'\\''"
        printf "'%s'" "$__quote_input"
    fi
}

__alias() {
    command='' name="$1"
    shift
    for x in "$@"; do
        x=$(__quote "$x") || return
        command="$command$x "
    done
    command="$command\"\$@\""
    filename="/usr/local/bin/$name"

    echo "#!/usr/bin/env sh" > "$filename" || return
    echo "$command" >> "$filename" || return
    chmod a+x "$filename" || return
    echo "Created command alias '$filename' of [$command]" 1>&2 || return
}

__bool() {
    bool=$(echo "$1" | __str upper)
    case "$bool" in
        0|OFF|NO|FALSE|N|IGNORE|NOTFOUND|""|*-NOTFOUND)
            return 1;;
        *)
            return 0;;
    esac
}

__boolstr() {
    if __bool "$@"; then
        printf "true"
    else
        printf "false"
    fi
}

__have_command() {
    __silently type "$1"
}

__do() {
    printf '%s\n' "$1"
    shift
    local output
    output="$("$@")"
    rc=$?
    if [ $rc != 0 ]; then
        printf %s "$output"
        return $rc
    fi
}

# Install the named packages using the platform's package manager.
# This script "just does the right thing" to install a package as a step in a
#   caching container build, as a bare "pkg-tool install" might be insufficient
#   or subtly broken, and we only really care about installing a list of packages
#
# Usage: <script> [pkgs...]
__install() {
    if test -f /etc/debian_version ; then
        # We *must* do a repo update as part of the install step in a single cache
        # layer, as a cached apt-get update can become stale while a later
        # apt-get install is invalidated
        apt-get -y update || return
        # DEBIAN_FRONTEND suppresses all interactivity. For some reason some
        # packages like to prompt as part of their config, even if we're not on
        # a TTY.
        test $# = 0 || env DEBIAN_FRONTEND=noninteractive \
            apt-get -y install -- "$@" || return
    elif test -f /etc/redhat-release || grep 'ID="amzn"' /etc/os-release >/dev/null 1>&2; then
        if test -f /usr/bin/dnf; then
            # 'dnf' will "do the right thing"
            test $# = 0 || dnf install -y "$@" || return
        elif test -f /usr/bin/yum; then
            test $# = 0 || yum install -y -- "$@" || return
            # 'yum' happily ignores missing packages. Use 'rpm -q' to check that
            # everything we requested actually got installed.
            test $# = 0 || if ! rpm -q -- "$@"; then
                echo "$0: Failing because one or more packages requested are not available"
                return 1
            fi
        else
            echo "No package manager here?" 1>&2
            exit 1
        fi
    elif test -f /etc/SuSE-brand \
        || (test -f /etc/os-release && grep "opensuse" /etc/os-release); then
        test $# = 0 || zypper --non-interactive install "$@" || return
    elif test -f /etc/arch-release; then
        test $# = 0 || pacman --sync --refresh --sysupgrade --quiet --noconfirm -- "$@" || return
    elif test -f /etc/alpine-release; then
        test $# = 0 || apk add -- "$@" || return
    else
        echo "$0: We don't know how to manage packages on this system" 1>&2
        return 1
    fi
}

__can_install() {
    # Refresh local package databases
    if test -f /etc/debian_version; then
        __silently apt-get -y update
    elif test -f /etc/alpine-release; then
        __silently apk update
    elif test -f /etc/arch-release; then
        __silently pacman --sync --refresh --quiet --noconfirm || :
    fi
    # If more than one package, test each one individually:
    if test $# -ne 1; then
        for pkg in "$@"; do
            __can_install_1 "$pkg" || return
        done
        return 0
    fi
    __can_install_1 "$1"
}

__can_install_1() {
    local package="$1"
    # Package checks:
    if test -f /etc/debian_version; then
        __silently apt-cache show -- "$package"
        return
    elif test -f /etc/redhat-release; then
        # "Yum" may be an alias for dnf, but this still works:
        __silently yum info "$package"
        return
    elif test -f /etc/arch-release; then
        __silently pacman --sync --info -- "$package"
        return
    elif test -f /etc/alpine-release; then
        __silently apk info -- "$package"
        return
    else
        echo "$0: We don't know how to manage packages on this system" 1>&2
        return 1
    fi
}

__silently() {
    "$@" > /dev/null 2>&1
}

__purpose() {
    __str test "${PURPOSE:-unset}" -matches "$1"
}

__STR_HELP='Usage:
  __str {lower,upper}
  __str test

Commands:
  lower, upper
    Convert input (stdin) to all-lowercase or all-uppercase, respectively

  test <str1> (-ieq|-ine|-contains|-matches) <str2>
    Like "test", but with additional string comparisons:
      -ieq • case-insensitive equal
      -ine • case-insensitive not-equal
      -contains • Check if <str1> contains <str2>
      -matches • Check if <str1> matches pattern <str2> (A grep -E pattern)
'
__str() {
  local _Command="$1"
  local _CommandIdent
  _CommandIdent="$(echo "__str__$_Command" | sed '
    s/-/_/g
    s/\./__/g
  ')"
  shift
  "$_CommandIdent" "$@"
}

__str__upper() {
  __justStdin upper __upper "$@"
}
__upper() {
  tr '[:lower:]' '[:upper:]'
}

__str__lower() {
  __justStdin lower __lower "$@"
}
__lower() {
  tr '[:upper:]' '[:lower:]'
}

__justStdin() {
  if test $# -gt 2; then
    __fail "Command '%s' does not take any arguments (write input into stdin)" "$1" || return
  fi
  "$2"
}

__str__help() {
  printf %s "$__STR_HELP"
}
__str____help() {
  __str help
}
__str___h() {
  __str help
}
__str___help() {
  __str help
}

__str__test() {
  test "$#" -eq 3 || fail '“str test” expects three arguments (Got %d: “%s”)' $# "$*" \
    || return
  local lhs="$1"
  local op="$2"
  local rhs="$3"
  local norm_lhs norm_rhs;
  norm_lhs=$(echo "$lhs" | __str lower) || return
  norm_rhs=$(echo "$rhs" | __str lower) || return
  case $op in
    -ieq)
      test "$norm_lhs" = "$norm_rhs";;
    -ine)
      test "$norm_lhs" != "$norm_rhs";;
    -matches)
      printf %s "$lhs" | grep -qE -- "$rhs";;
    -contains)
      printf %s "$lhs" | grep -qF -- "$rhs";;
    -*|=*)
      # Just defer to the underlying test command
      test "$lhs" "$op" "$rhs"
  esac
}

cmd=$1
shift
"$cmd" "$@"
